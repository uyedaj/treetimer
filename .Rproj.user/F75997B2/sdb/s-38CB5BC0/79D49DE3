{
    "contents" : "## Generalized workflow for obtaining a time-calibrated phylogeny from a list of taxa\nsetwd(\"~/repos/aRbor/aRbor\")\nrequire(devtools)\nrequire(foreach)\nrequire(doParallel)\nrequire(httr)\nrequire(rjson)\nrequire(rotl)\nrequire(phyndr)\nrm(list=ls(all=TRUE))\nload_all()\n\n## A few taxa to get a tree for\ntaxalist <- c(\"Drosophila_willistoni\", \"Felis_silvestris\", \"Homo_sapiens\", \"Aedes_vexans\", \"Gallus_gallus\", \"Lactuca_sativa\", \"Bidens\", \"Prunus\", \"Tinca_tinca\", \"Cotinis_nitida\")\n\nttol <- read.tree(\"http://www.biodiversitycenter.org/files/ttol/2.TTOL_all_smoothed.nwk\")\n\nregisterDoParallel(cores=12)\noptions(\"scipen\"=100, \"digits\"=4)\ntax <- foreach(i=1:length(taxalist)) %dopar% try(rotl::tnrs_match_names(taxalist[i]))\ntax <- do.call(rbind, tax)\ngenspec <- unname(sapply(tax[,2], function(x) paste(strsplit(x, split=\" \")[[1]][1:2],collapse=\" \")))\ngenspec <- gsub(\" (genus\", \" sp.\", genspec, fixed=TRUE)\ngenspec <- gsub(\" NA\", \" sp.\", genspec, fixed=TRUE)\ntax_unique <- tax[!duplicated(genspec),]\nottids <- as.character(tax_unique$ott_id) \n\nsynth_tree <- rotl::tol_induced_subtree(ott_ids=ottids)\nplot(synth_tree)\nsynth_tree <- reorder(synth_tree, \"postorder\")\nN <- length(synth_tree$tip.label)\n\npullLICAs <- function(tree, ott_sep=\"_ott\"){\n  tree <- reorder(tree, \"postorder\")\n  plot(tree)\n  N <- length(tree$tip.label)\n  nodeDesc <- lapply((N+1):(N+tree$Nnode),function(x) tips(tree, x))\n  if(!is.null(ott_sep)){\n    ottDesc <- lapply(nodeDesc, function(x) sapply(x, function(y) strsplit(y, ott_sep, fixed=TRUE)[[1]][2]))\n    ottids <- sapply(tree$tip.label, function(y) strsplit(y, ott_sep, fixed=TRUE)[[1]][2])\n  } else{\n    ottDesc <- lapply(nodeDesc, function(x) sapply(x, function(y) y))\n    ottids <- tree$tip.label\n  }\n  ottLICA <- lapply(ottDesc, function(x) rotl::taxonomy_lica(as.numeric(x)))\n  ottLICAs <- sapply(ottLICA, function(x) x$lica$'ot:ottId')\n  namesLICA <- sapply(ottLICA, function(x) x$lica$'ot:ottTaxonName')\n  nodelabels(namesLICA)\n  tree$node.label <- ottLICAs\n  ottsAll <- c(ottids, ottLICAs)\n  namesAll <- c(names(ottids), namesLICA)\n  names(ottsAll) <- names(namesAll) <- 1:(length(synth_tree$tip.label)+synth_tree$Nnode)\n  return(list(ottsLICA=ottLICAs, namesLICA=namesLICA, ottsAll=unname(ottsAll), namesAll=unname(namesAll)))\n}\n\n\ngetOttIds <- function(tree, cores=12, ...){\n  registerDoParallel(cores=cores)\n  taxalist <- tree$tip.label\n  taxalist <- unname(sapply(taxalist, function(x) gsub(\" sp.\", \"\", x)))\n  taxalist <- unname(sapply(taxalist, function(x) gsub(\"_sp.\", \"\", x)))\n  taxalist <- unname(sapply(taxalist, function(x) gsub(\" \", \"_\", x, fixed=TRUE)))\n  taxalist <- unname(sapply(taxalist, function(x) gsub(\"'\", \"\", x, fixed=TRUE)))\n  taxalist <-lapply(taxalist, function(x) paste(strsplit(x, \"_\")[[1]][1:2], collapse=\"_\"))\n  taxalist <- unname(sapply(taxalist, function(x) gsub(\"_NA\", \"\", x, fixed=TRUE)))\n  context <- rotl::tnrs_infer_context(names = taxalist)$context_name\n  tax <- foreach(i=1:length(taxalist)) %dopar% try(rotl::tnrs_match_names(taxalist, context_name=context, ...))\n  tax <- do.call(rbind, tax)\n  return(tax)\n}\n\nsynth_tree <- reorder(synth_tree, \"postorder\")\nlicas <- pullLICAs(synth_tree)\ndummy <- setNames(rep(0, N), synth_tree$tip.label)\ndummytree <- synth_tree\ndummytree$edge.length <- rep(1, nrow(dummytree$edge))\ncache <- geiger:::.prepare.bm.univariate(dummytree, dummy)\nadesc <- cache$desc$adesc\nfdesc <- cache$desc$fdesc\n\n#tmp <- lapply(licas$ottsLICA, function(x) findsourcetrees(as.character(x)))\n\n\ngetNodeDates <- function(i){\n  sources <- do.call(rbind, lapply(licas$ottsLICA, function(x) findsourcetrees(as.character(x))))\n  #RLsources <- lapply(fdesc[[i]], function(x) findsourcetrees(licas$ottsAll[adesc[[x]]]))\n  #uniquesources <- lapply(RLsources, function(x) paste(x[,1], x[,2]))\n  #toGet <- RLsources[[1]][which(uniquesources[[1]] %in% uniquesources[[2]]),]\n  uniquesources <- paste(sources[,1], sources[,2])\n  toGet <- sources[!duplicated(uniquesources),]\n  studyTrees <- getStudyTrees(toGet, min=1, add=\"?tip_label=ot:ottid\")\n  \n  timetrees <- studyTrees$result[which(studyTrees$summary$timeUnits==\"Myr\")]\n  timetrees <- lapply(timetrees, function(x) x[[1]])\n  timetrees_treeId <- studyTrees$summary[which(studyTrees$summary$timeUnits==\"Myr\"),'tree']\n  timetrees_studyId <- studyTrees$summary[which(studyTrees$summary$timeUnits==\"Myr\"),'study']\n  studyMeta <- lapply(timetrees_studyId, function(x) rotl::get_study_meta(study_id = x))\n  citations <- lapply(studyMeta, function(x) x$nexml[[2]])\n  \n  hangDates <- function(tree, target_otts){\n    missing <- grep(\"not_mapped\", tree$tip.label)\n    if(length(missing) > 1) tree <- drop.tip(tree, missing)\n    tmp <- pullLICAs(tree, ott_sep=NULL)\n    matching_nodes <- which(target_otts %in% tmp$ottsLICA)\n    if(length(matching_nodes > 0)){\n      match_table <- data.frame(\"ottid\"=tmp[[1]], \"name\"=tmp[[2]], \"node\"=matching_nodes)[matching_nodes, ]\n      match_table <- match_table[!duplicated(match_table[,1]),]\n      match_table$date <- unname(branching.times(tree)[match_table$node])\n    } else {\n      match_table <- NULL\n    }\n    print(match_table)\n    return(match_table)\n  }\n  nodeDates <- lapply(1:length(timetrees), function(x) try(hangDates(timetrees[[x]], licas$ottsLICA)))\n  nodeDates <- lapply(1:length(timetrees), function(x) if(is.null(nodeDates[[x]])){ NULL} else{data.frame(study=timetrees_studyId[x], tree=timetrees_treeId[x], nodeDates[[x]])})\n  nodeDates <- do.call(rbind, nodeDates)\n\n  return(nodeDates)\n}\n\n\n\nhangDates(timetrees[[3]][[2]], licas$ottsLICA)\n\nnodeDates <- NULL\nfor(i in 11:19){\n  nodeDates <- rbind(nodeDates, getNodeDates(i))\n}\n\n\n## Using lineages\n\nlineages <- lapply(ottids, taxonomy_lineage)\nfind_daughter_taxa <- function(ottids, lineage_list){\n  tmp <- lapply(ottids, function(ott) do.call(rbind, lapply(lineage_list, function(ll) ll[which(ll[,1]==ott)-1,])))\n  tmp <- lapply(tmp, function(x) x[!duplicated(x[,1]),])\n  return(tmp)\n}\n\ndaughters <- find_daughter_taxa(licas$ottsLICA, lineages)\nlicatrees <- lapply(daughters, function(x) try(findsourcetrees(as.character(unlist(x$ottid)))))\nlicatrees <- lapply(sourcetrees, function(x) subset(x, x$counts>1))\n\nstudyTrees <- lapply(licatrees, function(x) getStudyTrees(x, min=1, add=\"?tip_label=ot:ottid\"))\ntimetrees <- lapply(studyTrees, function(x) x$result[which(x$summary$timeUnits==\"Myr\")])\ntmp <- pullLICAs(timetrees[[1]][[1]][[1]], ott_sep=NULL)\n                    \ni=9\npullLICAs(timetrees[[9]]$tree[[1]])\n\n",
    "created" : 1447370717224.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "2555543601",
    "id" : "79D49DE3",
    "lastKnownWriteTime" : 1431537933,
    "path" : "~/repos/aRbor/BobTreeWorkflow/GeneralizedWorkflow.R",
    "project_path" : null,
    "properties" : {
    },
    "relative_order" : 3,
    "source_on_save" : false,
    "type" : "r_source"
}