{
    "contents" : "## # Download the latest version of the timetree of life\ngetTTOL <- function(treeNumber=2, list.only=FALSE){\n  timetrees <- c(\n    \"TTOL_all_unsmoothed\",\n    \"TTOL_all_smoothed\",\n    \"TTOL_animals_unsmoothed\",\n    \"TTOL_plants_unsmoothed\",\n    \"TTOL_fungi_unsmoothed\",\n    \"TTOL_birds_unsmoothed\",\n    \"TTOL_birds_smoothed_interpolated\",\n    \"TTOL_mammals_unsmoothed\",\n    \"TTOL_mammals_smoothed_interpolated\",\n    \"TTOL_squamates_unsmoothed\",\n    \"TTOL_amphibians_unsmoothed\",\n    \"TTOL_actinopterygians_unsmoothed\",\n    \"TTOL_arthropods_unsmoothed\",\n    \"TTOL_mollusks_unsmoothed\",\n    \"TTOL_cnidarians_unsmoothed\",\n    \"TTOL_ascomycetes_unsmoothed\",\n    \"TTOL_basidiomycetes_unsmoothed\",\n    \"TTOL_angiosperms_unsmoothed\",\n    \"TTOL_gymnosperms_unsmoothed\",\n    \"TTOL_moniliformopses_unsmoothed\",\n    \"TTOL_liverworts_unsmoothed\",\n    \"TTOL_mosses_unsmoothed\",\n    \"TTOL_chlorophytes_unsmoothed\",\n    \"TTOL_diatoms_unsmoothed\",\n    \"TTOL_phaeophyceans_unsmoothed\",\n    \"TTOL_eubacteria_unsmoothed\",\n    \"TTOL_archaebacteria_unsmoothed\")\n  if(list.only){\n    print(paste(1:length(timetrees), timetrees, sep=\".\"))\n  } else {\n    treename <- paste(treeNumber, timetrees[treeNumber], sep=\".\")\n    url <- paste(\"http://www.biodiversitycenter.org/files/ttol/\",treename,\".nwk\", sep=\"\")\n    tree <- read.tree(url)\n    return(tree)\n  }\n}\n\n## # Build taxonomy for the timetree of life\ngetOttIds <- function(taxalist, ncores=1){\n  scipen <- options()$scipen\n  digits <- options()$digits\n  options(\"scipen\"=100, \"digits\"=4)\n  .taxalist <- gsub(\"_\", \" \", taxalist)\n  tax <- parallel::mclapply(1:length(taxalist),  function(i) try(rotl::tnrs_match_names(.taxalist[i], do_approximate_matching =FALSE)), mc.cores=ncores)\n  failed <- which(sapply(tax,function(x) class(x)[1]==\"try-error\"))\n  if(length(failed)>0){\n    tax[failed] <- parallel::mclapply(failed,  function(i) try(rotl::tnrs_match_names(.taxalist[i], do_approximate_matching =TRUE)), mc.cores=ncores)\n  }\n  stillfailed <- which(sapply(tax,function(x) class(x)[1]==\"try-error\"))\n  if(length(stillfailed>0)){\n    tax[stillfailed] <- lapply(stillfailed, function(x) data.frame(search_string=.taxalist[x], unique_name=NA, approximate_match=NA, ott_id=NA, is_synonym=NA, is_deprecated=NA, number_matches=0))\n  }\n  tax <- do.call(rbind, tax)\n  genspec <- unname(sapply(tax[,2], function(x) paste(strsplit(x, split=\" \")[[1]][1:2],collapse=\" \")))\n  genspec <- gsub(\" (genus\", \" sp.\", genspec, fixed=TRUE)\n  genspec <- gsub(\" NA\", \" sp.\", genspec, fixed=TRUE)\n  tax_unique <- tax[!duplicated(genspec),]\n  tax_unique$ottids <- as.character(tax_unique$ott_id)\n  options(\"scipen\"=scipen, \"digits\"=digits)\n  tax_unique[,1] <- gsub(\" \", \"_\", tax_unique[,1])\n  tax_unique[,1] <- sapply(tax_unique[,1], function(x) simpleCap(x))\n  return(tax_unique)\n}\n\nsimpleCap <- function(x) {\n  s <- strsplit(x, \" \")[[1]]\n  paste(toupper(substring(s, 1,1)), substring(s, 2),\n        sep=\"\", collapse=\" \")\n}\n\n.nodeHeights <- function(tree, scale=\"YBP\"){\n  branchTimes <- branching.times(tree)\n  TH <- max(branchTimes)\n  n.tip <- length(tree$tip.label)\n  branchTimes <- c(setNames(rep(0, n.tip), 1:n.tip), branchTimes)\n  nH <- cbind(branchTimes[tree$edge[,1]], branchTimes[tree$edge[,2]])\n  if(scale==\"YBP\"){\n    return(nH)\n  }\n  if(scale==\"ABS\"){\n    return(TH-nH)\n  }\n}\n\ngetBranchesSlice <- function(slice, tree){\n  nH <- .nodeHeights(tree)\n  present <- unname(which(apply(nH, 1, function(x) slice > x[2] & slice < x[1])))\n  return(list(branches=present, nodes=tree$edge[present,2]))\n}\n\nsliceTaxonomyTable <- function(slices, tree, lookupLICAs=FALSE, ottTable=NULL){\n  cache <- geiger:::.prepare.bm.univariate(tree, setNames(rep(1,length(tree$tip.label)), tree$tip.label))\n  TH <- max(branching.times(tree))\n  nodeSlices <- lapply(slices, function(x) getBranchesSlice(x, tree)$nodes)\n  tipDescendents <- lapply(nodeSlices, function(x) cache$desc$tips[x])\n  tipNames <-lapply(tipDescendents, function(x) lapply(x, function(y) cache$phy$tip.label[y]))\n  if(lookupLICAs){\n    tipOtts <- lapply(tipDescendents, function(x) lapply(x, function(y) ottTable$ott_id[y]))\n    tipLICAs <- mclapply(tipOtts, function(x) sapply(x, function(y) rotl::taxonomy_lica(ott_ids=as.character(y))$lica$'ot:ottTaxonName'), mc.cores=2)\n  }\n  tipDescendents <- lapply(tipDescendents, function(x) do.call(rbind, lapply(1:length(x), function(y) cbind(y, x[[y]]))))\n  if(lookupLICAs){\n    tipLicaDesc <- lapply(1:length(tipDescendents), function(x) data.frame(tipDescendents[[x]],taxName=tipLICAs[[x]][tipDescendents[[x]][,1]]))\n    tax <- do.call(cbind, lapply(length(slices):1, function(x) as.character(tipLicaDesc[[x]][order(tipLicaDesc[[x]][,2]),3])))\n    colnames(tax) <- paste(\"rank\",1:ncol(tax), sep=\"\")\n    tax <- data.frame(tip=cache$phy$tip.label, tax)\n    } else {\n    tax <- do.call(cbind, lapply(length(slices):1, function(x) tipDescendents[[x]][order(tipDescendents[[x]][,2]),1]))\n    colnames(tax) <- paste(\"rank\",ncol(tax):1, sep=\"\")\n    tax <- data.frame(tip=cache$phy$tip.label, tax)\n  }\n  return(tax)\n}\n\n## # Create a list of lineage tables\nextractLineages <- function(ottids, ncores, ottnames=NULL){\n  .extractFromRaw <- function(raw){data.frame(do.call(rbind, lapply(raw[[1]]$taxonomic_lineage, function(x) data.frame(otName=x$'ot:ottTaxonName', rank=x$rank, ottid=x$'ot:ottId', unique_name=x$unique_name) )))}\n  lineages_raw <- mclapply(ottids, function(x) rotl::taxonomy_taxon(x, include_lineage=TRUE), mc.cores=ncores)\n  lineageTable <- lapply(lineages_raw, .extractFromRaw)\n  if(!is.null(ottnames)){\n    names(lineageTable) <- ottnames\n  }\n  return(lineageTable)\n}\n\nsimpleCap <- function(x) {\n  s <- strsplit(x, \" \")[[1]]\n  paste(toupper(substring(s, 1,1)), substring(s, 2),\n        sep=\"\", collapse=\" \")\n}\n\n\nmatchLineages <- function(dataLineages, treeLineages, tree){\n  matches <- lapply(dataLineages, function(x) sapply(treeLineages, function(y) sum(x$ottid %in% y$ottid)))\n  matchIds <- lapply(matches, function(x) which(x==max(x)))\n  matchTaxa <- lapply(matchIds, function(x) tree$tip.label[x])\n  names(matchTaxa) <- names(matchIds) <- names(matches) <- names(dataLineages)\n  return(list(taxa=matchTaxa, ids=matchIds))\n}\n\nresolveDataTaxonomy <- function(matches, taxonomy){\n  taxonomies <- lapply(matches$ids, function(x) taxonomy[x, ])\n  .simplifyTaxonomy <- function(table, tip){\n    shared <- apply(table[,-1], 2, function(x) length(unique(x))==1)\n    taxrow <- table[1,-1]\n    taxrow[!shared] <- NA\n    cbind(tip, taxrow)\n  }\n  res <- lapply(1:length(taxonomies), function(x) .simplifyTaxonomy(taxonomies[[x]], names(taxonomies)[x]))\n  res <- do.call(rbind, res)\n  rownames(res) <- 1:nrow(res)\n  res[is.na(res)] <- length((unique(unlist(taxonomy[,-1])))) + 1:length(res[is.na(res)])\n  res\n}\n\nphyndrTTOL <- function(ttolObject, taxalist, timeslices, prune=TRUE, ncores=1){\n  tree     <- ttolObject$phy\n  dat      <- ttolObject$dat\n  lineages <- ttolObject$lineages\n  tax <- sliceTaxonomyTable(timeslices, tree, lookupLICAs = FALSE)\n  rm(ttolObject)\n  dataOttTable <- getOttIds(taxalist, ncores=ncores)\n  dataLineages <- extractLineages(dataOttTable$ott_id, ncores=ncores, ottnames=taxalist)\n  matchTaxonomy <- matchLineages(dataLineages, lineages, tree)\n  dataTaxonomy <- resolveDataTaxonomy(matchTaxonomy, tax)\n  if(prune){\n    colLICA <- min(which(apply(dataTaxonomy[,-1], 2, function(x) length(unique(x))==1)))\n    dataLICA <- unique(dataTaxonomy[, colLICA])\n    drop <- which(!(tax[,colLICA] %in% dataLICA))\n    ## Loop through higher taxnomic levels not in the data taxonomy and select only one species\n    if(colLICA > 2){\n      for(j in (colLICA-1):2){\n        drop <- c(drop, which(!(tax[,j] %in% dataTaxonomy[,j]) & duplicated(tax[,j])))\n      }\n    }\n    drop <- unique(drop)\n    if(length(drop) > 0){\n      ptree <- phyndr:::drop_tip(tree, tree$tip.label[drop])\n      ptax <- tax[-drop, ]\n    } else {\n      ptree <- tree\n      ptax <- tax\n    }\n  } else {\n    ptree <- tree\n    ptax <- tax\n  }\n  fulltax <- rbind(ptax, dataTaxonomy)\n  fulltax <- fulltax[!duplicated(fulltax[,1]),]\n  rownames(fulltax) <- fulltax[,1]\n  fulltax <- fulltax[,-1]\n  fakenames <- sapply(1:max(unique(unlist(fulltax))), function(x) paste(sample(LETTERS, 12,replace=TRUE), collapse=\"\"))\n  fulltax[1:ncol(fulltax)] <- apply(fulltax, 2, function(x) fakenames[x])\n  #fulltax <- apply(fulltax,2,function(x){class(x) <- \"character\"; x})\n  phynd <- phyndr_taxonomy(ptree, taxalist, fulltax)\n  return(list(otts=dataOttTable, taxonomy=fulltax, phyndr=phynd))\n}\n",
    "created" : 1447796882982.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "118|59|126|0|\n",
    "hash" : "2714577646",
    "id" : "83EC328E",
    "lastKnownWriteTime" : 1447914109,
    "path" : "~/repos/aRbor/treetimer/R/data-processing.R",
    "project_path" : "R/data-processing.R",
    "properties" : {
        "tempName" : "Untitled1"
    },
    "relative_order" : 3,
    "source_on_save" : true,
    "type" : "r_source"
}